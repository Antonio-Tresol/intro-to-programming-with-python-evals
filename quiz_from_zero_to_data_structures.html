<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kahoot de Python</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <!-- Fira Code Font & Highlight.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/firacode@6.2.0/distr/fira_code.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
        }
        .google-bg {
            background-color: #f8f9fa;
        }
        .google-shadow {
            box-shadow: 0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -2px rgba(0,0,0,.1);
        }
        .option-card {
            background-color: #282c34; /* Atom One Dark background for all cards */
            border-left-width: 6px; /* Accent border */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s;
            display: flex;
            align-items: center; /* Vertically center content */
            min-height: 80px;
            height: 100%; /* Ensures cards in the same row have equal height */
            padding: 0; /* Remove padding as it's handled by the inner pre element */
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .option-card:hover:not(:disabled) {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 12px 20px -3px rgba(0, 0, 0, 0.2);
        }
        /* Styles for the code block with Fira Code and highlight.js */
        .code-block {
            font-family: 'Fira Code', 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9rem;
            border-radius: 8px;
            overflow: hidden;
        }
        .code-block code {
            border-radius: 8px !important;
        }
        
        /* Explanation container with scroll for long content */
        #explanation-container {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Markdown generated content styles */
        #explanation-container ul, #explanation-container ol {
            list-style-position: inside;
            padding-left: 1rem;
            text-align: left;
        }
        #explanation-container ul { list-style-type: disc; }
        #explanation-container ol { list-style-type: decimal; }
        #explanation-container a { color: #1a73e8; text-decoration: underline; }
        
        /* Syntax highlighting for inline code in explanations */
        #explanation-container code {
            background-color: rgba(0,0,0,0.08);
            padding: 3px 6px;
            border-radius: 6px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
        }

        /* Unified styling for all options, now treated as code blocks */
        .option-card pre {
            text-align: left;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            width: 100%;
            background-color: transparent !important;
            color: #abb2bf; /* Default text color for Atom One Dark */
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .option-card pre code {
            background-color: transparent !important;
            padding: 0;
            font-size: inherit;
        }
        
        /* Accent colors for borders */
        .border-accent-red { border-color: #DB4437; }
        .border-accent-blue { border-color: #4285F4; }
        .border-accent-yellow { border-color: #F4B400; }
        .border-accent-green { border-color: #0F9D58; }
        
        /* Animaciones */
        .slide-in { animation: slide-in 0.5s forwards; }
        .slide-out { animation: slide-out 0.5s forwards; }
        @keyframes slide-in {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slide-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }

        /* Feedback styling now applied to the whole card */
        .feedback-correct { animation: feedback-pop 0.5s ease-out; background-color: #0F9D58 !important; border-color: white !important; }
        .feedback-incorrect { animation: feedback-shake 0.5s ease-in-out; background-color: #DB4437 !important; border-color: white !important; }
        .feedback-highlight-correct { border-color: #0F9D58 !important; }
        
        /* Ensure text is readable on feedback */
        .feedback-correct pre, .feedback-correct pre code,
        .feedback-incorrect pre, .feedback-incorrect pre code {
            color: white !important;
        }
        .feedback-correct .hljs-string, .feedback-incorrect .hljs-string { color: #e2e2e2 !important; }
        .feedback-correct .hljs-number, .feedback-incorrect .hljs-number { color: #d6d6d6 !important; }
        .feedback-correct .hljs-keyword, .feedback-incorrect .hljs-keyword { color: #f2f2f2 !important; }


        @keyframes feedback-pop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes feedback-shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-10px); }
            40%, 80% { transform: translateX(10px); }
        }
    </style>
</head>
<body class="google-bg min-h-screen flex items-center justify-center p-4">

    <div id="quiz-container" class="w-full max-w-4xl mx-auto bg-white rounded-2xl google-shadow overflow-hidden">
        
        <div id="start-screen" class="p-8 md:p-12 text-center">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-800 mb-4">Quiz de Comprensión de Python</h1>
            <p class="text-gray-600 text-lg mb-8">¿Listo para el desafío? ¡Demuestra tus conocimientos de Python!</p>
            <button id="start-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-10 rounded-full text-xl transition-transform transform hover:scale-105">
                ¡Empezar!
            </button>
        </div>

        <div id="question-screen" class="hidden p-6 md:p-8">
            <div class="flex justify-between items-center mb-4">
                <span id="question-counter" class="text-gray-500 font-semibold"></span>
                <span id="score" class="text-blue-600 font-bold text-lg">Puntaje: 0</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            
            <div class="question-content">
                <h2 id="question-title" class="text-2xl font-bold text-gray-800 mb-4 text-center"></h2>
                <div id="code-snippet" class="mb-6 code-block"></div>
                <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Las opciones se generarán aquí -->
                </div>
                <div id="explanation-container" class="hidden mt-6 p-4 rounded-lg bg-blue-50 border-l-4 border-blue-500 text-gray-700">
                    <!-- La explicación aparecerá aquí -->
                </div>
                <div class="mt-4 text-center">
                    <button id="next-btn" class="hidden bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-10 rounded-full text-lg transition-transform transform hover:scale-105">
                        Siguiente
                    </button>
                </div>
            </div>
        </div>
        
        <div id="result-screen" class="hidden p-8 md:p-12 text-center">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-800 mb-2">¡Juego Terminado!</h1>
            <p class="text-gray-600 text-xl mb-6">Tu puntaje final es:</p>
            <p id="final-score" class="text-7xl font-bold text-blue-600 mb-8"></p>
            <button id="restart-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-10 rounded-full text-xl transition-transform transform hover:scale-105">
                Jugar de Nuevo
            </button>
        </div>
    </div>
    
    <!-- Highlight.js Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    
    <script>
        /**
         * @file Main script for the Python Kahoot-style Quiz application.
         * @description This script handles the quiz logic, state management, and DOM manipulation.
         * The architecture is designed for maintainability and scalability, making it easy to add new questions.
         */

        // --- 1. CONFIGURATION & DATA ---

        /**
         * @description The main data source for the quiz.
         * To add a new question, simply copy an existing question object and paste it at the end of this array.
         * You can use Markdown for formatting in 'question' and 'explanation'.
         * For options, simply provide the string. For multi-line, formatted code in options, use template literals (backticks).
         *
         * TEMPLATE FOR NEW QUESTION:
         * {
         * question: "Your *Markdown-enabled* question text here?",
         * code: `Your Python code snippet here. Use backticks for multi-line strings.`,
         * options: ["Option A", "Option B", `A multi-line
         * option formatted like code`, "Option D"],
         * correct: `A multi-line
         * option formatted like code`,
         * explanation: "A detailed *Markdown-enabled* explanation of why the answer is correct."
         * },
         */
        const quizData = [
            {
                question: "¿Cuál será el valor de retorno al llamarla con `funcion_uno(5, 3)`?",
                code: `from typing import Union

def funcion_uno(a: int, b: int) -> bool:
    x: int = a + b * 2
    y: bool = (x % 5) > 2
    z: bool = not y and (a > b)
    return z`,
                options: ["False", "True", "11", "Error de sintaxis"],
                correct: "True",
                explanation: `
* **Paso 1: Calcular \`x\`**: Por [precedencia de operadores](https://www.w3schools.com/python/python_operators.asp), \`3 * 2\` se evalúa primero (6). Luego \`5 + 6 = 11\`. Así que \`x\` es \`11\`.
* **Paso 2: Calcular \`y\`**: La expresión es \`(11 % 5) > 2\`. El módulo \`11 % 5\` es \`1\`. La comparación \`1 > 2\` es **False**. Así que \`y\` es \`False\`.
* **Paso 3: Calcular \`z\`**: La expresión es \`not y and (a > b)\`. Esto se convierte en \`not False and (5 > 3)\`, que es \`True and True\`. El resultado final es **True**.
`
            },
            {
                question: "¿Cuál es la salida de la siguiente función si se invoca con `funcion_dos([1, 2, 3, 4, 5])`?",
                code: `from typing import List

def funcion_dos(numeros: List[int]) -> List[int]:
    resultado: List[int] = []
    for n in numeros:
        if n % 2 == 0:
            resultado.append(n * 2)
        else:
            continue
    return resultado`,
                options: ["[2, 4]", "[2, 4, 6, 8, 10]", "[4, 8]", "[1, 3, 5]"],
                correct: "[4, 8]",
                explanation: "El ciclo itera sobre la lista. La condición `n % 2 == 0` solo es verdadera para los números pares (2 y 4). Para estos, se agrega su doble a la lista `resultado`. Así, se añade `2*2=4` y `4*2=8`. Los números impares se omiten con `continue`."
            },
            {
                question: "¿Qué retornará la llamada `funcion_tres(['b', 'c', 'd', 'e'])`?",
                code: `from typing import List

def funcion_tres(data: List[str]) -> List[str]:
    data[0] = 'a'
    data.pop()
    return data`,
                options: ["['b', 'c', 'd']", "['a', 'c', 'd', 'e']", "['b', 'c', 'd', 'e']", "['a', 'c', 'd']"],
                correct: "['a', 'c', 'd']",
                explanation: "Las listas son mutables. Primero, `data[0] = 'a'` cambia el primer elemento. La lista se convierte en `['a', 'c', 'd', 'e']`. Luego, `.pop()` elimina el último elemento, resultando en `['a', 'c', 'd']`."
            },
            {
                question: "¿Cuál es el resultado de ejecutar `funcion_cuatro` con el diccionario proporcionado?",
                code: `from typing import Dict, Any

def funcion_cuatro(diccionario: Dict[str, Any]) -> int:
    contador: int = 0
    for clave, valor in diccionario.items():
        if isinstance(valor, int) and valor > 10:
            contador += len(clave)
    return contador

# Llamada: funcion_cuatro({'id': 1, 'nombre': 'ana', 'puntos': 25, 'nivel': 'tres'})`,
                options: ["1", "25", "6", "11"],
                correct: "6",
                explanation: "La función itera sobre el diccionario. La condición solo se cumple para `'puntos': 25` (es un entero mayor que 10). En ese caso, se suma la longitud de la clave `len('puntos')`, que es 6, al contador."
            },
            {
                question: "¿Cuál será la salida al invocarla con `procesar_lista([1, 2, 3, 4, 5, 6])`?",
                code: `from typing import List

def procesar_lista(numeros: List[int]) -> List[int]:
    cuadrados_pares = [n**2 for n in numeros if n % 2 == 0]
    cuadrados_pares.sort(reverse=True)
    return cuadrados_pares`,
                options: ["[4, 16, 36]", "[36, 16, 4]", "[1, 4, 9, 16, 25, 36]", "[36, 4]"],
                correct: "[36, 16, 4]",
                explanation: "La comprensión de lista filtra los números pares `[2, 4, 6]` y luego los eleva al cuadrado, creando `[4, 16, 36]`. Finalmente, `.sort(reverse=True)` ordena esta lista en orden descendente."
            },
            {
                question: "¿Qué cadena retornará la función con el diccionario `{'usuario': 'alex', 'estado': 'activo'}`?",
                code: `from typing import Dict, Any

def manipular_diccionario(info: Dict[str, Any]) -> str:
    info['estado'] = 'inactivo'
    info['visitas'] = 1
    if info.get('visitas', 0) > 0:
        info['usuario'] = info['usuario'].capitalize()
    return f"{info['usuario']} está {info['estado']}"`,
                options: [`"alex está inactivo"`, `"Alex está activo"`, `"Alex está inactivo"`, `"alex está activo"`],
                correct: `"Alex está inactivo"`,
                explanation: "El diccionario es mutable. Se actualiza `estado` a `'inactivo'` y se añade `visitas`. La condición del `if` es verdadera, por lo que `'usuario'` se capitaliza a `'Alex'`. La cadena final se forma con estos valores actualizados."
            },
            {
                question: "Considerando la siguiente función *recursiva*, ¿cuál es el resultado de la llamada `recursividad_factorial(4)`?",
                code: `def recursividad_factorial(n: int) -> int:
    if n == 0:
        return 1
    else:
        return n * recursividad_factorial(n - 1)`,
                options: ["24", "10", "4", "Error por recursión infinita"],
                correct: "24",
                explanation: "Esta es una función recursiva para calcular el factorial. Se resuelve como `4 * 3 * 2 * 1 * 1`, lo que da como resultado `24`. El caso base `n == 0` detiene la recursión."
            },
            {
                question: "¿Qué valor retornará la función si se invoca con las listas `[1, 2, 3, 4]` y `[3, 4, 5, 6]`?",
                code: `from typing import List, Set

def operaciones_conjuntos(lista1: List[int], lista2: List[int]) -> int:
    conjunto1: Set[int] = set(lista1)
    conjunto2: Set[int] = set(lista2)
    interseccion: Set[int] = conjunto1.intersection(conjunto2)
    return sum(interseccion)`,
                options: ["10", "28", "7", "Un conjunto {3, 4}"],
                correct: "7",
                explanation: "Las listas se convierten en conjuntos. El método `.intersection()` encuentra los elementos comunes, que son `{3, 4}`. La función `sum()` calcula la suma de estos elementos: `3 + 4 = 7`."
            },
            {
                question: "¿Cuál es el valor de retorno al llamarla con `procesar_cadenas(['Python', 'Framework', 'Agil'])`?",
                code: `from typing import List, Dict

def procesar_cadenas(cadenas: List[str]) -> Dict[str, int]:
    resultado: Dict[str, int] = {}
    vocales: str = "aeiou"
    for cadena in cadenas:
        contador_vocales: int = 0
        for caracter in cadena.lower():
            if caracter in vocales:
                contador_vocales += 1
        if contador_vocales > 2:
            resultado[cadena] = len(cadena)
    return resultado`,
                options: ["{'Python': 6, 'Framework': 9, 'Agil': 4}", "{'Framework': 3}", "{'Framework': 9}", "{'Python': 1, 'Framework': 3, 'Agil': 2}"],
                correct: "{'Framework': 9}",
                explanation: "La función cuenta las vocales en cada cadena (ignorando mayúsculas/minúsculas). Solo si una cadena tiene más de 2 vocales, se añade al diccionario de resultado con su longitud como valor. 'Framework' tiene 3 vocales ('a', 'e', 'o'), cumpliendo la condición."
            },
            {
                question: "¿Cuál será la salida de la función `agrupar_datos` si se invoca con la lista `[('A', 2), ('B', 3), ('A', 4)]`?",
                code: `from typing import List, Tuple, Dict

def agrupar_datos(datos: List[Tuple[str, int]]) -> Dict[str, List[int]]:
    agrupado: Dict[str, List[int]] = {}
    for clave, valor in datos:
        if clave not in agrupado:
            agrupado[clave] = []
        agrupado[clave].append(valor * valor)
    return agrupado`,
                options: ["{'A': [2, 4], 'B': [3]}", "{'A': [4, 16], 'B': [9]}", "{'A': [4], 'B': [9]}", "{'A': [16], 'B': [9]}"],
                correct: "{'A': [4, 16], 'B': [9]}",
                explanation: "La función agrupa los valores de las tuplas por su clave. Para cada valor, lo eleva al cuadrado antes de añadirlo a la lista correspondiente en el diccionario. Para 'A', añade 2*2=4 y luego 4*4=16. Para 'B', añade 3*3=9."
            },
            {
                question: "Considera la siguiente función y el código que la invoca. ¿Cuál es el valor final de la variable `z`?",
                code: `from typing import Tuple

def calcular_operaciones(x: int, y: int = 2) -> Tuple[int, int, bool]:
    suma: int = x + y
    producto: int = x * y
    es_mayor: bool = (suma > producto)
    return suma, producto, es_mayor

# Código de invocación
resultado: Tuple[int, int, bool] = calcular_operaciones(3)
z: int = resultado[0] - resultado[1]`,
                options: ["5", "6", "-1", "False"],
                correct: "-1",
                explanation: "La función se llama con `x=3`. El parámetro `y` toma su valor por defecto, `2`. La función retorna la tupla `(5, 6, False)`. La variable `z` se calcula como la resta del primer elemento (`5`) y el segundo (`6`) de la tupla, resultando en `-1`."
            },
            {
                question: "¿Qué cadena de texto retornará la función `analizar_numero` al ser llamada con el argumento `9`?",
                code: `def analizar_numero(num: int) -> str:
    if num % 3 == 0 and num % 5 == 0:
        return "Divisible por 3 y 5"
    elif num % 3 == 0 or num % 2 == 0:
        if num > 10:
            return "Opción A"
        else:
            return "Opción B"
    else:
        return "Opción C"`,
                options: ["Divisible por 3 y 5", "Opción A", "Opción B", "Opción C"],
                correct: "Opción B",
                explanation: "Se evalúa `num = 9`. El primer `if` es falso. El `elif` es verdadero porque `9 % 3 == 0`. Dentro de este bloque, la condición anidada `9 > 10` es falsa, por lo que se ejecuta el `else` anidado, que retorna 'Opción B'."
            },
            {
                question: "Dada la función para procesar lecturas de sensores, ¿cuál será el valor de retorno al llamarla como se indica?",
                code: `from typing import List, Dict, Any

def validar_y_promediar_lecturas(
    lecturas: List[Dict[str, Any]], 
    id_objetivo: str, 
    valor_min: float) -> float:
    valores_validos: List[float] = []
    for lectura in lecturas:
        if (lectura.get('sensor_id') == id_objetivo and
            lectura.get('status') == 'ok' and
            isinstance(lectura.get('value'), (int, float)) and
            lectura.get('value', 0) >= valor_min):
            valores_validos.append(lectura['value'])

    if not valores_validos:
        return 0.0
    return sum(valores_validos) / len(valores_validos)

# Llamada: validar_y_promediar_lecturas(datos_sensores, 'temp-01', 0.0)`,
                options: ["13.53", "22.8", "45.6", "263.525"],
                correct: "22.8",
                explanation: `
La función debe encontrar el promedio de las lecturas del sensor 'temp-01' con estado 'ok' y un valor no menor a 0.0. Analicemos cada lectura:
* \`{'sensor_id': 'temp-01', 'value': 22.5, 'status': 'ok'}\`: **Cumple** todas las condiciones. Se añade \`22.5\` a la lista.
* \`{'sensor_id': 'temp-01', 'value': -5.0, 'status': 'ok'}\`: **No cumple** la condición del valor mínimo (\`-5.0 < 0.0\`). Se ignora.
* \`{'sensor_id': 'pres-01', 'value': 1012.5, 'status': 'ok'}\`: **No cumple** la condición del ID del sensor. Se ignora.
* \`{'sensor_id': 'temp-01', 'value': 23.1, 'status': 'error'}\`: **No cumple** la condición del estado (\`'error' != 'ok'\`). Se ignora.
* \`{'sensor_id': 'temp-01', 'value': 23.1, 'status': 'ok'}\`: **Cumple** todas las condiciones. Se añade \`23.1\` a la lista.

La lista de valores válidos es \`[22.5, 23.1]\`. El cálculo final es el promedio: \`(22.5 + 23.1) / 2 = 22.8\`.
`
            },
            {
                question: "Esta función consolida un lote de lecturas. ¿Qué diccionario retornará?",
                code: `from typing import List, Dict, Any

def consolidar_datos_sensores(lecturas: List[Dict[str, Any]]) -> Dict[str, Dict[str, float]]:
    resumen: Dict[str, Dict[str, float]] = {}
    for lectura in lecturas:
        sensor_id = lectura.get('id')
        valor = lectura.get('value')
        
        if not sensor_id or not isinstance(valor, (int, float)):
            continue

        if sensor_id not in resumen:
            resumen[sensor_id] = {'conteo': 0, 'total': 0.0, 'maximo': -float('inf')}
        
        resumen[sensor_id]['conteo'] += 1
        resumen[sensor_id]['total'] += valor
        resumen[sensor_id]['maximo'] = max(resumen[sensor_id]['maximo'], valor)
    return resumen

# Llamada: consolidar_datos_sensores(lecturas_lote)`,
                options: [
                    "{'hum-01': {'conteo': 2, ...}, 'temp-02': {'conteo': 2, ...}}", 
                    "[{'id': 'hum-01', 'conteo': 2}, ...]", 
                    "{'Error': 'Valor no numérico'}", 
                    `{
    'hum-01': {'conteo': 2, 'total': 131.5, 'maximo': 66.0},
    'temp-02': {'conteo': 2, 'total': 31.3, 'maximo': 16.1}
}`
                ],
                correct: `{
    'hum-01': {'conteo': 2, 'total': 131.5, 'maximo': 66.0},
    'temp-02': {'conteo': 2, 'total': 31.3, 'maximo': 16.1}
}`,
                explanation: `
La función itera sobre la lista y construye un diccionario de resúmenes.
* **Lectura 1 \`{'id': 'hum-01', ...}\`**: Se inicializa el resumen para 'hum-01': \`{'conteo': 1, 'total': 65.5, 'maximo': 65.5}\`.
* **Lectura 2 \`{'id': 'temp-02', ...}\`**: Se inicializa el resumen para 'temp-02': \`{'conteo': 1, 'total': 15.2, 'maximo': 15.2}\`.
* **Lectura 3 \`{'id': 'hum-01', ...}\`**: Se actualiza 'hum-01': \`conteo\` a 2, \`total\` a 131.5, y \`maximo\` a \`max(65.5, 66.0)\` que es \`66.0\`.
* **Lectura 4 \`{'id': 'temp-02', value: 'N/A'}\`**: El valor 'N/A' no es numérico, por lo que **se ignora**.
* **Lectura 5 \`{'id': 'temp-02', ...}\`**: Se actualiza 'temp-02': \`conteo\` a 2, \`total\` a \`15.2 + 16.1 = 31.3\`, y \`maximo\` a \`max(15.2, 16.1)\` que es \`16.1\`.

El resumen final contiene las estadísticas consolidadas para ambos sensores, coincidiendo con la opción correcta.
`
            },
            {
                question: "Analiza el código y los datos de entrada. ¿Cuál es el estado final del `inventario_jugador` después de la llamada a la función?",
                code: `from typing import List, Dict, Any

def actualizar_inventario(
    inventario: Dict[str, Dict[str, Any]], 
    items_nuevos: List[str], 
    catalogo_items: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    
    for item_id in items_nuevos:
        if item_id in inventario:
            if inventario[item_id].get('stackable', False):
                inventario[item_id]['cantidad'] += 1
        else:
            if item_id in catalogo_items:
                inventario[item_id] = catalogo_items[item_id].copy()
    return inventario

# Datos iniciales
inventario_jugador = {
    'pocion_mana': {'cantidad': 3, 'stackable': True},
    'espada_unica': {'cantidad': 1, 'stackable': False}
}
catalogo_juego = {
    'pocion_mana': {'cantidad': 1, 'stackable': True},
    'flecha_acero': {'cantidad': 1, 'stackable': True},
    'espada_unica': {'cantidad': 1, 'stackable': False}
}
nuevos_hallazgos = ['pocion_mana', 'flecha_acero', 'espada_unica', 'flecha_acero']

# Llamada
actualizar_inventario(inventario_jugador, nuevos_hallazgos, catalogo_juego)`,
                options: [
                    `{
    'pocion_mana': {'cantidad': 4, 'stackable': True},
    'espada_unica': {'cantidad': 1, 'stackable': False},
    'flecha_acero': {'cantidad': 2, 'stackable': True}
}`,
                    `{
    'pocion_mana': {'cantidad': 4, 'stackable': True},
    'espada_unica': {'cantidad': 2, 'stackable': False},
    'flecha_acero': {'cantidad': 2, 'stackable': True}
}`,
                    `{
    'pocion_mana': {'cantidad': 4, 'stackable': True},
    'espada_unica': {'cantidad': 1, 'stackable': False},
    'flecha_acero': {'cantidad': 1, 'stackable': True}
}`,
                    `{
    'pocion_mana': {'cantidad': 3, 'stackable': True},
    'espada_unica': {'cantidad': 1, 'stackable': False},
    'flecha_acero': {'cantidad': 2, 'stackable': True}
}`
                ],
                correct: `{
    'pocion_mana': {'cantidad': 4, 'stackable': True},
    'espada_unica': {'cantidad': 1, 'stackable': False},
    'flecha_acero': {'cantidad': 2, 'stackable': True}
}`,
                explanation: `
La función itera sobre la lista \`nuevos_hallazgos\`:
1.  **'pocion_mana'**: Ya existe y es apilable (\`stackable: True\`). Su cantidad aumenta de 3 a **4**.
2.  **'flecha_acero'**: No existe. Se añade una copia desde el catálogo. El inventario ahora tiene \`'flecha_acero': {'cantidad': 1, 'stackable': True}\`.
3.  **'espada_unica'**: Existe, pero **no** es apilable (\`stackable: False\`). No se hace nada.
4.  **'flecha_acero'**: Ahora ya existe y es apilable. Su cantidad aumenta de 1 a **2**.

El estado final del inventario combina estas modificaciones.
`
            },
            {
                question: "Dado el personaje, la habilidad y una tirada de crítico de **15**, ¿cuál es el daño final (redondeado a entero) que calcula la función?",
                code: `from typing import Dict

def calcular_danio_final(
    personaje: Dict[str, float], 
    habilidad: Dict[str, float], 
    tirada_critico: float) -> int:
    
    danio_base_total = habilidad['base_damage'] + (personaje['fuerza'] * habilidad['escala_fuerza'])
    danio_final = danio_base_total
    
    if tirada_critico <= personaje['crit_chance']:
        danio_final = danio_base_total * personaje['crit_damage']
        
    return int(danio_final)

# Datos
guerrero = {
    'fuerza': 50.0,
    'crit_chance': 20.0,
    'crit_damage': 1.5
}
ataque_pesado = {
    'base_damage': 30.0,
    'escala_fuerza': 1.2
}

# Llamada
calcular_danio_final(guerrero, ataque_pesado, 15.0)`,
                options: ["135", "90", "142", "60"],
                correct: "135",
                explanation: `
El cálculo se realiza en dos fases:
1.  **Cálculo del daño sin crítico**:
    * Bono por fuerza: \`50.0 * 1.2 = 60.0\`.
    * Daño total base: \`30.0 + 60.0 = 90.0\`.
2.  **Verificación de golpe crítico**:
    * La condición es \`tirada_critico <= personaje['crit_chance']\`, que es \`15.0 <= 20.0\`. Esto es **verdadero**.
    * El ataque es un golpe crítico.
3.  **Cálculo del daño final**:
    * Se multiplica el daño base por el modificador de crítico: \`90.0 * 1.5 = 135.0\`.

La función retorna la parte entera, que es **135**.
`
            }
            // <-- Pega aquí tu nueva pregunta
        ];

        /**
         * @description Constants for DOM element IDs to avoid magic strings.
         */
        const DOM_SELECTORS = {
            quizContainer: 'quiz-container',
            startScreen: 'start-screen',
            questionScreen: 'question-screen',
            resultScreen: 'result-screen',
            startBtn: 'start-btn',
            restartBtn: 'restart-btn',
            nextBtn: 'next-btn',
            questionCounter: 'question-counter',
            score: 'score',
            progressBar: 'progress-bar',
            questionTitle: 'question-title',
            codeSnippet: 'code-snippet',
            optionsContainer: 'options-container',
            explanationContainer: 'explanation-container',
            finalScore: 'final-score',
        };

        /**
         * @description Constants for CSS classes used for dynamic styling.
         */
        const CSS_CLASSES = {
            hidden: 'hidden',
            slideIn: 'slide-in',
            optionCard: 'option-card',
            feedbackCorrect: 'feedback-correct',
            feedbackIncorrect: 'feedback-incorrect',
            feedbackHighlightCorrect: 'feedback-highlight-correct',
            accentBorders: ['border-accent-red', 'border-accent-blue', 'border-accent-yellow', 'border-accent-green'],
        };

        // --- 2. APPLICATION LOGIC (The Quiz App Module) ---

        /**
         * @module QuizApp
         * @description Encapsulates all the logic for the quiz application.
         */
        const QuizApp = {
            /**
             * Application state
             * @property {number} score - The user's current score.
             * @property {number} currentQuestionIndex - The index of the current question in the shuffled array.
             * @property {Array<Object>} questions - The shuffled array of question data.
             * @property {Object} dom - References to all necessary DOM elements.
             */
            state: {
                score: 0,
                currentQuestionIndex: 0,
                questions: [],
                dom: {},
            },

            /**
             * Initializes the application.
             * Caches DOM elements and sets up event listeners.
             */
            init() {
                // Cache all DOM elements once
                for (const key in DOM_SELECTORS) {
                    this.state.dom[key] = document.getElementById(DOM_SELECTORS[key]);
                }
                this.addEventListeners();
            },

            /**
             * Binds all necessary event listeners.
             */
            addEventListeners() {
                this.state.dom.startBtn.addEventListener('click', () => this.start());
                this.state.dom.restartBtn.addEventListener('click', () => this.start());
                this.state.dom.nextBtn.addEventListener('click', () => this.nextQuestion());
            },

            /**
             * Starts or restarts the quiz.
             * Resets state, shuffles questions, and shows the first question.
             */
            start() {
                this.state.score = 0;
                this.state.currentQuestionIndex = 0;
                this.state.questions = [...quizData].sort(() => Math.random() - 0.5);

                this.updateScreen(this.state.dom.questionScreen, [this.state.dom.startScreen, this.state.dom.resultScreen]);
                this.renderQuestion();
            },

            /**
             * Renders the current question and its associated UI elements.
             */
            renderQuestion() {
                const questionData = this.state.questions[this.state.currentQuestionIndex];
                const { dom } = this.state;

                // Hide explanation from previous question
                dom.explanationContainer.classList.add(CSS_CLASSES.hidden);
                dom.nextBtn.classList.add(CSS_CLASSES.hidden);

                // Animate question appearance
                const questionContent = dom.questionScreen.querySelector('.question-content');
                questionContent.classList.remove(CSS_CLASSES.slideIn);
                void questionContent.offsetWidth; // Force reflow for animation restart
                questionContent.classList.add(CSS_CLASSES.slideIn);
                
                this.updateProgress();
                
                dom.questionTitle.innerHTML = marked.parse(questionData.question);
                this.renderCode(questionData.code);
                this.renderOptions(questionData.options, questionData.correct);
            },

            /**
             * Updates the score and progress bar.
             */
            updateProgress() {
                const { score, currentQuestionIndex, questions, dom } = this.state;
                const progressPercentage = ((currentQuestionIndex + 1) / questions.length) * 100;
                
                dom.score.textContent = `Puntaje: ${score}`;
                dom.progressBar.style.width = `${progressPercentage}%`;
                dom.questionCounter.textContent = `Pregunta ${currentQuestionIndex + 1} de ${questions.length}`;
            },
            
            /**
             * Renders the code snippet with syntax highlighting.
             * @param {string} code - The Python code to display.
             */
            renderCode(code) {
                const { dom } = this.state;
                const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                dom.codeSnippet.innerHTML = `<pre><code class="language-python">${escapedCode}</code></pre>`;
                hljs.highlightElement(dom.codeSnippet.querySelector('code'));
            },
            
            /**
             * Renders the answer options.
             * @param {string[]} options - An array of answer strings.
             * @param {string} correctOption - The correct answer string.
             */
            renderOptions(options, correctOption) {
                const { dom } = this.state;
                dom.optionsContainer.innerHTML = '';
                
                // Shuffle options so they don't appear in the same order every time
                const shuffledOptions = [...options].sort(() => Math.random() - 0.5);

                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    button.dataset.optionValue = option; 
                    
                    // UNIFIED RENDERING: Treat all options as code blocks for visual consistency.
                    const escapedCode = option.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    button.innerHTML = `<pre><code class="language-python">${escapedCode}</code></pre>`;
                    hljs.highlightElement(button.querySelector('code'));
                    
                    button.classList.add(
                        CSS_CLASSES.optionCard, 'transition',
                        CSS_CLASSES.accentBorders[index % 4]
                    );
                    button.onclick = () => this.handleAnswer(button, option, correctOption);
                    dom.optionsContainer.appendChild(button);
                });
            },
            
            /**
             * Handles the user's answer selection.
             * @param {HTMLButtonElement} button - The button element that was clicked.
             * @param {string} selectedOption - The option string selected by the user.
             *
             * @param {string} correctOption - The correct answer string for the question.
             */
            handleAnswer(button, selectedOption, correctOption) {
                const { dom } = this.state;
                
                // Disable all option buttons
                Array.from(dom.optionsContainer.children).forEach(btn => {
                    btn.disabled = true;
                    btn.style.cursor = 'not-allowed';
                });

                if (selectedOption.trim() === correctOption.trim()) {
                    this.state.score += 10;
                    dom.score.textContent = `Puntaje: ${this.state.score}`;
                    button.classList.add(CSS_CLASSES.feedbackCorrect);
                } else {
                    button.classList.add(CSS_CLASSES.feedbackIncorrect);
                    // Highlight the correct answer
                    Array.from(dom.optionsContainer.children).forEach(btn => {
                        if (btn.dataset.optionValue.trim() === correctOption.trim()) {
                           btn.classList.add(CSS_CLASSES.feedbackHighlightCorrect);
                        }
                    });
                }
                
                this.showExplanation();
            },
            
            /**
             * Displays the explanation for the current question.
             */
            showExplanation() {
                const { dom, questions, currentQuestionIndex } = this.state;
                const explanation = questions[currentQuestionIndex].explanation;
                dom.explanationContainer.innerHTML = `<strong>Explicación:</strong> ${marked.parse(explanation)}`;
                dom.explanationContainer.classList.remove(CSS_CLASSES.hidden);
                dom.nextBtn.classList.remove(CSS_CLASSES.hidden);
            },

            /**
             * Moves to the next question or shows the results screen.
             */
            nextQuestion() {
                this.state.currentQuestionIndex++;
                if (this.state.currentQuestionIndex < this.state.questions.length) {
                    this.renderQuestion();
                } else {
                    this.showResults();
                }
            },

            /**
             * Displays the final results screen.
             */
            showResults() {
                this.state.dom.finalScore.textContent = this.state.score;
                this.updateScreen(this.state.dom.resultScreen, [this.state.dom.questionScreen]);
            },
            
            /**
             * Helper function to manage screen transitions.
             * @param {HTMLElement} screenToShow - The screen element to display.
             * @param {Array<HTMLElement>} screensToHide - An array of screen elements to hide.
             */
            updateScreen(screenToShow, screensToHide = []) {
                screensToHide.forEach(screen => screen.classList.add(CSS_CLASSES.hidden));
                screenToShow.classList.remove(CSS_CLASSES.hidden);
                screenToShow.classList.add(CSS_CLASSES.slideIn);
            }
        };
        
        // --- 3. INITIALIZATION ---
        // Start the application once the DOM is fully loaded.
        document.addEventListener('DOMContentLoaded', () => {
            QuizApp.init();
        });
    </script>
</body>
</html>

